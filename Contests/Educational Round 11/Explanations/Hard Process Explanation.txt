
Here's the trick. 

Maintain two pointers, [L, R]. 

We want the largest segment with at most k 0s. 

now, to do this fix L and let R go as far as possible till it has at most k 0s. 

Once there are more than K 0's, then

Increment L till there are <= K 0's. 

Now, if R is at position X, when no of 0's = K + 1, 

There is no need to start checking all segments from [L + 1, L + 2], [L + 1, L + 3], .... [L + 1, X] and so on and so forth. 

We know that [L, X - 1] was a good segment. And all these segments are smaller than it. 

We only need to check larger segments. So for every possible left from [L, X- 1], we check only larger intervals, [L + 1, X + 1] and so on. 

If we know [L, X - 1] is a good segment, there is no need to check intervals smaller than that. 

---------------------------------------

int main()
{
    int no_of_elements, max_zeroes;
    scanf("%d %d", &no_of_elements, &max_zeroes);

    vector <int> A(no_of_elements + 1);
    for(int i = 1; i <= no_of_elements; i++) scanf("%d", &A[i]);

    int no_of_0s = 0;
    int change_left = 0, change_right = 0, left = 1, right = 1, max_window_size = 0;

    while(right <= no_of_elements)
    {
        if(A[right] == 0)
            no_of_0s++;

        while(no_of_0s > max_zeroes)
        {
            if(A[left] == 0)
                no_of_0s--;

            left++;
        }

        int window_size = right - (left - 1);
        if(window_size > max_window_size)
        {
            max_window_size = window_size, change_left = left, change_right = right;
        }

        right++;
    }

    for(int i = change_left; i <= change_right; i++) A[i] = 1;

    printf("%d\n", max_window_size);
    for(int i = 1; i <= no_of_elements; i++) printf("%d ", A[i]);

    return 0;
}
